// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension ChimeSdkMediaPipelinesClientTypes.ArtifactsConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case audio = "Audio"
        case content = "Content"
        case video = "Video"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let audio = self.audio {
            try encodeContainer.encode(audio, forKey: .audio)
        }
        if let content = self.content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let video = self.video {
            try encodeContainer.encode(video, forKey: .video)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let audioDecoded = try containerValues.decodeIfPresent(ChimeSdkMediaPipelinesClientTypes.AudioArtifactsConfiguration.self, forKey: .audio)
        audio = audioDecoded
        let videoDecoded = try containerValues.decodeIfPresent(ChimeSdkMediaPipelinesClientTypes.VideoArtifactsConfiguration.self, forKey: .video)
        video = videoDecoded
        let contentDecoded = try containerValues.decodeIfPresent(ChimeSdkMediaPipelinesClientTypes.ContentArtifactsConfiguration.self, forKey: .content)
        content = contentDecoded
    }
}

extension ChimeSdkMediaPipelinesClientTypes {
    /// The configuration for the artifacts.
    public struct ArtifactsConfiguration: Swift.Equatable {
        /// The configuration for the audio artifacts.
        /// This member is required.
        public var audio: ChimeSdkMediaPipelinesClientTypes.AudioArtifactsConfiguration?
        /// The configuration for the content artifacts.
        /// This member is required.
        public var content: ChimeSdkMediaPipelinesClientTypes.ContentArtifactsConfiguration?
        /// The configuration for the video artifacts.
        /// This member is required.
        public var video: ChimeSdkMediaPipelinesClientTypes.VideoArtifactsConfiguration?

        public init (
            audio: ChimeSdkMediaPipelinesClientTypes.AudioArtifactsConfiguration? = nil,
            content: ChimeSdkMediaPipelinesClientTypes.ContentArtifactsConfiguration? = nil,
            video: ChimeSdkMediaPipelinesClientTypes.VideoArtifactsConfiguration? = nil
        )
        {
            self.audio = audio
            self.content = content
            self.video = video
        }
    }

}

extension ChimeSdkMediaPipelinesClientTypes {
    public enum ArtifactsState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [ArtifactsState] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "Disabled"
            case .enabled: return "Enabled"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ArtifactsState(rawValue: rawValue) ?? ArtifactsState.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSdkMediaPipelinesClientTypes.AudioArtifactsConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case muxType = "MuxType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let muxType = self.muxType {
            try encodeContainer.encode(muxType.rawValue, forKey: .muxType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let muxTypeDecoded = try containerValues.decodeIfPresent(ChimeSdkMediaPipelinesClientTypes.AudioMuxType.self, forKey: .muxType)
        muxType = muxTypeDecoded
    }
}

extension ChimeSdkMediaPipelinesClientTypes {
    /// The audio artifact configuration object.
    public struct AudioArtifactsConfiguration: Swift.Equatable {
        /// The MUX type of the audio artifact configuration object.
        /// This member is required.
        public var muxType: ChimeSdkMediaPipelinesClientTypes.AudioMuxType?

        public init (
            muxType: ChimeSdkMediaPipelinesClientTypes.AudioMuxType? = nil
        )
        {
            self.muxType = muxType
        }
    }

}

extension ChimeSdkMediaPipelinesClientTypes {
    public enum AudioMuxType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case audioonly
        case audiowithactivespeakervideo
        case sdkUnknown(Swift.String)

        public static var allCases: [AudioMuxType] {
            return [
                .audioonly,
                .audiowithactivespeakervideo,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .audioonly: return "AudioOnly"
            case .audiowithactivespeakervideo: return "AudioWithActiveSpeakerVideo"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AudioMuxType(rawValue: rawValue) ?? AudioMuxType.sdkUnknown(rawValue)
        }
    }
}

extension BadRequestException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: BadRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
            self.requestId = output.requestId
        } else {
            self.code = nil
            self.message = nil
            self.requestId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The input parameters don't match the service's restrictions.
public struct BadRequestException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: ChimeSdkMediaPipelinesClientTypes.ErrorCode?
    public var message: Swift.String?
    /// The request id associated with the call responsible for the exception.
    public var requestId: Swift.String?

    public init (
        code: ChimeSdkMediaPipelinesClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
        self.requestId = requestId
    }
}

struct BadRequestExceptionBody: Swift.Equatable {
    let code: ChimeSdkMediaPipelinesClientTypes.ErrorCode?
    let message: Swift.String?
    let requestId: Swift.String?
}

extension BadRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
        case requestId = "RequestId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeSdkMediaPipelinesClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension ChimeSdkMediaPipelinesClientTypes.ChimeSdkMeetingConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case artifactsConfiguration = "ArtifactsConfiguration"
        case sourceConfiguration = "SourceConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let artifactsConfiguration = self.artifactsConfiguration {
            try encodeContainer.encode(artifactsConfiguration, forKey: .artifactsConfiguration)
        }
        if let sourceConfiguration = self.sourceConfiguration {
            try encodeContainer.encode(sourceConfiguration, forKey: .sourceConfiguration)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSdkMediaPipelinesClientTypes.SourceConfiguration.self, forKey: .sourceConfiguration)
        sourceConfiguration = sourceConfigurationDecoded
        let artifactsConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSdkMediaPipelinesClientTypes.ArtifactsConfiguration.self, forKey: .artifactsConfiguration)
        artifactsConfiguration = artifactsConfigurationDecoded
    }
}

extension ChimeSdkMediaPipelinesClientTypes {
    /// The configuration object of the Amazon Chime SDK meeting for a specified media capture pipeline. SourceType must be ChimeSdkMeeting.
    public struct ChimeSdkMeetingConfiguration: Swift.Equatable {
        /// The configuration for the artifacts in an Amazon Chime SDK meeting.
        public var artifactsConfiguration: ChimeSdkMediaPipelinesClientTypes.ArtifactsConfiguration?
        /// The source configuration for a specified media capture pipline.
        public var sourceConfiguration: ChimeSdkMediaPipelinesClientTypes.SourceConfiguration?

        public init (
            artifactsConfiguration: ChimeSdkMediaPipelinesClientTypes.ArtifactsConfiguration? = nil,
            sourceConfiguration: ChimeSdkMediaPipelinesClientTypes.SourceConfiguration? = nil
        )
        {
            self.artifactsConfiguration = artifactsConfiguration
            self.sourceConfiguration = sourceConfiguration
        }
    }

}

extension ChimeSdkMediaPipelinesClientTypes.ContentArtifactsConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case muxType = "MuxType"
        case state = "State"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let muxType = self.muxType {
            try encodeContainer.encode(muxType.rawValue, forKey: .muxType)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateDecoded = try containerValues.decodeIfPresent(ChimeSdkMediaPipelinesClientTypes.ArtifactsState.self, forKey: .state)
        state = stateDecoded
        let muxTypeDecoded = try containerValues.decodeIfPresent(ChimeSdkMediaPipelinesClientTypes.ContentMuxType.self, forKey: .muxType)
        muxType = muxTypeDecoded
    }
}

extension ChimeSdkMediaPipelinesClientTypes {
    /// The content artifact object.
    public struct ContentArtifactsConfiguration: Swift.Equatable {
        /// The MUX type of the artifact configuration.
        public var muxType: ChimeSdkMediaPipelinesClientTypes.ContentMuxType?
        /// Indicates whether the content artifact is enabled or disabled.
        /// This member is required.
        public var state: ChimeSdkMediaPipelinesClientTypes.ArtifactsState?

        public init (
            muxType: ChimeSdkMediaPipelinesClientTypes.ContentMuxType? = nil,
            state: ChimeSdkMediaPipelinesClientTypes.ArtifactsState? = nil
        )
        {
            self.muxType = muxType
            self.state = state
        }
    }

}

extension ChimeSdkMediaPipelinesClientTypes {
    public enum ContentMuxType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case contentonly
        case sdkUnknown(Swift.String)

        public static var allCases: [ContentMuxType] {
            return [
                .contentonly,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .contentonly: return "ContentOnly"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ContentMuxType(rawValue: rawValue) ?? ContentMuxType.sdkUnknown(rawValue)
        }
    }
}

extension CreateMediaCapturePipelineInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateMediaCapturePipelineInput(chimeSdkMeetingConfiguration: \(Swift.String(describing: chimeSdkMeetingConfiguration)), sinkType: \(Swift.String(describing: sinkType)), sourceType: \(Swift.String(describing: sourceType)), tags: \(Swift.String(describing: tags)), clientRequestToken: \"CONTENT_REDACTED\", sinkArn: \"CONTENT_REDACTED\", sourceArn: \"CONTENT_REDACTED\")"}
}

extension CreateMediaCapturePipelineInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case chimeSdkMeetingConfiguration = "ChimeSdkMeetingConfiguration"
        case clientRequestToken = "ClientRequestToken"
        case sinkArn = "SinkArn"
        case sinkType = "SinkType"
        case sourceArn = "SourceArn"
        case sourceType = "SourceType"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let chimeSdkMeetingConfiguration = self.chimeSdkMeetingConfiguration {
            try encodeContainer.encode(chimeSdkMeetingConfiguration, forKey: .chimeSdkMeetingConfiguration)
        }
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let sinkArn = self.sinkArn {
            try encodeContainer.encode(sinkArn, forKey: .sinkArn)
        }
        if let sinkType = self.sinkType {
            try encodeContainer.encode(sinkType.rawValue, forKey: .sinkType)
        }
        if let sourceArn = self.sourceArn {
            try encodeContainer.encode(sourceArn, forKey: .sourceArn)
        }
        if let sourceType = self.sourceType {
            try encodeContainer.encode(sourceType.rawValue, forKey: .sourceType)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

extension CreateMediaCapturePipelineInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/sdk-media-capture-pipelines"
    }
}

public struct CreateMediaCapturePipelineInput: Swift.Equatable {
    /// The configuration for a specified media capture pipeline. SourceType must be ChimeSdkMeeting.
    public var chimeSdkMeetingConfiguration: ChimeSdkMediaPipelinesClientTypes.ChimeSdkMeetingConfiguration?
    /// The token assigned to the client making the pipeline request.
    public var clientRequestToken: Swift.String?
    /// The ARN of the sink type.
    /// This member is required.
    public var sinkArn: Swift.String?
    /// Destination type to which the media artifacts are saved. You must use an S3 bucket.
    /// This member is required.
    public var sinkType: ChimeSdkMediaPipelinesClientTypes.MediaPipelineSinkType?
    /// ARN of the source from which the media artifacts are captured.
    /// This member is required.
    public var sourceArn: Swift.String?
    /// Source type from which the media artifacts are captured. A Chime SDK Meeting is the only supported source.
    /// This member is required.
    public var sourceType: ChimeSdkMediaPipelinesClientTypes.MediaPipelineSourceType?
    /// The list of tags.
    public var tags: [ChimeSdkMediaPipelinesClientTypes.Tag]?

    public init (
        chimeSdkMeetingConfiguration: ChimeSdkMediaPipelinesClientTypes.ChimeSdkMeetingConfiguration? = nil,
        clientRequestToken: Swift.String? = nil,
        sinkArn: Swift.String? = nil,
        sinkType: ChimeSdkMediaPipelinesClientTypes.MediaPipelineSinkType? = nil,
        sourceArn: Swift.String? = nil,
        sourceType: ChimeSdkMediaPipelinesClientTypes.MediaPipelineSourceType? = nil,
        tags: [ChimeSdkMediaPipelinesClientTypes.Tag]? = nil
    )
    {
        self.chimeSdkMeetingConfiguration = chimeSdkMeetingConfiguration
        self.clientRequestToken = clientRequestToken
        self.sinkArn = sinkArn
        self.sinkType = sinkType
        self.sourceArn = sourceArn
        self.sourceType = sourceType
        self.tags = tags
    }
}

struct CreateMediaCapturePipelineInputBody: Swift.Equatable {
    let sourceType: ChimeSdkMediaPipelinesClientTypes.MediaPipelineSourceType?
    let sourceArn: Swift.String?
    let sinkType: ChimeSdkMediaPipelinesClientTypes.MediaPipelineSinkType?
    let sinkArn: Swift.String?
    let clientRequestToken: Swift.String?
    let chimeSdkMeetingConfiguration: ChimeSdkMediaPipelinesClientTypes.ChimeSdkMeetingConfiguration?
    let tags: [ChimeSdkMediaPipelinesClientTypes.Tag]?
}

extension CreateMediaCapturePipelineInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case chimeSdkMeetingConfiguration = "ChimeSdkMeetingConfiguration"
        case clientRequestToken = "ClientRequestToken"
        case sinkArn = "SinkArn"
        case sinkType = "SinkType"
        case sourceArn = "SourceArn"
        case sourceType = "SourceType"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceTypeDecoded = try containerValues.decodeIfPresent(ChimeSdkMediaPipelinesClientTypes.MediaPipelineSourceType.self, forKey: .sourceType)
        sourceType = sourceTypeDecoded
        let sourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceArn)
        sourceArn = sourceArnDecoded
        let sinkTypeDecoded = try containerValues.decodeIfPresent(ChimeSdkMediaPipelinesClientTypes.MediaPipelineSinkType.self, forKey: .sinkType)
        sinkType = sinkTypeDecoded
        let sinkArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sinkArn)
        sinkArn = sinkArnDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let chimeSdkMeetingConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSdkMediaPipelinesClientTypes.ChimeSdkMeetingConfiguration.self, forKey: .chimeSdkMeetingConfiguration)
        chimeSdkMeetingConfiguration = chimeSdkMeetingConfigurationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ChimeSdkMediaPipelinesClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ChimeSdkMediaPipelinesClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ChimeSdkMediaPipelinesClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateMediaCapturePipelineOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateMediaCapturePipelineOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateMediaCapturePipelineOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateMediaCapturePipelineOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateMediaCapturePipelineOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.mediaCapturePipeline = output.mediaCapturePipeline
        } else {
            self.mediaCapturePipeline = nil
        }
    }
}

public struct CreateMediaCapturePipelineOutputResponse: Swift.Equatable {
    /// A media capture pipeline object, the ID, source type, source ARN, sink type, and sink ARN of a media capture pipeline object.
    public var mediaCapturePipeline: ChimeSdkMediaPipelinesClientTypes.MediaCapturePipeline?

    public init (
        mediaCapturePipeline: ChimeSdkMediaPipelinesClientTypes.MediaCapturePipeline? = nil
    )
    {
        self.mediaCapturePipeline = mediaCapturePipeline
    }
}

struct CreateMediaCapturePipelineOutputResponseBody: Swift.Equatable {
    let mediaCapturePipeline: ChimeSdkMediaPipelinesClientTypes.MediaCapturePipeline?
}

extension CreateMediaCapturePipelineOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mediaCapturePipeline = "MediaCapturePipeline"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mediaCapturePipelineDecoded = try containerValues.decodeIfPresent(ChimeSdkMediaPipelinesClientTypes.MediaCapturePipeline.self, forKey: .mediaCapturePipeline)
        mediaCapturePipeline = mediaCapturePipelineDecoded
    }
}

extension DeleteMediaCapturePipelineInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let mediaPipelineId = mediaPipelineId else {
            return nil
        }
        return "/sdk-media-capture-pipelines/\(mediaPipelineId.urlPercentEncoding())"
    }
}

public struct DeleteMediaCapturePipelineInput: Swift.Equatable {
    /// The ID of the media capture pipeline being deleted.
    /// This member is required.
    public var mediaPipelineId: Swift.String?

    public init (
        mediaPipelineId: Swift.String? = nil
    )
    {
        self.mediaPipelineId = mediaPipelineId
    }
}

struct DeleteMediaCapturePipelineInputBody: Swift.Equatable {
}

extension DeleteMediaCapturePipelineInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteMediaCapturePipelineOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteMediaCapturePipelineOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteMediaCapturePipelineOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteMediaCapturePipelineOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteMediaCapturePipelineOutputResponse: Swift.Equatable {

    public init () { }
}

extension ChimeSdkMediaPipelinesClientTypes {
    public enum ErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case badrequest
        case forbidden
        case notfound
        case resourcelimitexceeded
        case servicefailure
        case serviceunavailable
        case throttling
        case sdkUnknown(Swift.String)

        public static var allCases: [ErrorCode] {
            return [
                .badrequest,
                .forbidden,
                .notfound,
                .resourcelimitexceeded,
                .servicefailure,
                .serviceunavailable,
                .throttling,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .badrequest: return "BadRequest"
            case .forbidden: return "Forbidden"
            case .notfound: return "NotFound"
            case .resourcelimitexceeded: return "ResourceLimitExceeded"
            case .servicefailure: return "ServiceFailure"
            case .serviceunavailable: return "ServiceUnavailable"
            case .throttling: return "Throttling"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ErrorCode(rawValue: rawValue) ?? ErrorCode.sdkUnknown(rawValue)
        }
    }
}

extension ForbiddenException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ForbiddenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
            self.requestId = output.requestId
        } else {
            self.code = nil
            self.message = nil
            self.requestId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The client is permanently forbidden from making the request.
public struct ForbiddenException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: ChimeSdkMediaPipelinesClientTypes.ErrorCode?
    public var message: Swift.String?
    /// The request id associated with the call responsible for the exception.
    public var requestId: Swift.String?

    public init (
        code: ChimeSdkMediaPipelinesClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
        self.requestId = requestId
    }
}

struct ForbiddenExceptionBody: Swift.Equatable {
    let code: ChimeSdkMediaPipelinesClientTypes.ErrorCode?
    let message: Swift.String?
    let requestId: Swift.String?
}

extension ForbiddenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
        case requestId = "RequestId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeSdkMediaPipelinesClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension GetMediaCapturePipelineInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let mediaPipelineId = mediaPipelineId else {
            return nil
        }
        return "/sdk-media-capture-pipelines/\(mediaPipelineId.urlPercentEncoding())"
    }
}

public struct GetMediaCapturePipelineInput: Swift.Equatable {
    /// The ID of the pipeline that you want to get.
    /// This member is required.
    public var mediaPipelineId: Swift.String?

    public init (
        mediaPipelineId: Swift.String? = nil
    )
    {
        self.mediaPipelineId = mediaPipelineId
    }
}

struct GetMediaCapturePipelineInputBody: Swift.Equatable {
}

extension GetMediaCapturePipelineInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetMediaCapturePipelineOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetMediaCapturePipelineOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetMediaCapturePipelineOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetMediaCapturePipelineOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetMediaCapturePipelineOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.mediaCapturePipeline = output.mediaCapturePipeline
        } else {
            self.mediaCapturePipeline = nil
        }
    }
}

public struct GetMediaCapturePipelineOutputResponse: Swift.Equatable {
    /// The media capture pipeline object.
    public var mediaCapturePipeline: ChimeSdkMediaPipelinesClientTypes.MediaCapturePipeline?

    public init (
        mediaCapturePipeline: ChimeSdkMediaPipelinesClientTypes.MediaCapturePipeline? = nil
    )
    {
        self.mediaCapturePipeline = mediaCapturePipeline
    }
}

struct GetMediaCapturePipelineOutputResponseBody: Swift.Equatable {
    let mediaCapturePipeline: ChimeSdkMediaPipelinesClientTypes.MediaCapturePipeline?
}

extension GetMediaCapturePipelineOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mediaCapturePipeline = "MediaCapturePipeline"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mediaCapturePipelineDecoded = try containerValues.decodeIfPresent(ChimeSdkMediaPipelinesClientTypes.MediaCapturePipeline.self, forKey: .mediaCapturePipeline)
        mediaCapturePipeline = mediaCapturePipelineDecoded
    }
}

extension ListMediaCapturePipelinesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListMediaCapturePipelinesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/sdk-media-capture-pipelines"
    }
}

public struct ListMediaCapturePipelinesInput: Swift.Equatable {
    /// The maximum number of results to return in a single call. Valid Range: 1 - 99.
    public var maxResults: Swift.Int?
    /// The token used to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListMediaCapturePipelinesInputBody: Swift.Equatable {
}

extension ListMediaCapturePipelinesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListMediaCapturePipelinesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListMediaCapturePipelinesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLimitExceededException" : self = .resourceLimitExceededException(try ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListMediaCapturePipelinesOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case resourceLimitExceededException(ResourceLimitExceededException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListMediaCapturePipelinesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListMediaCapturePipelinesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.mediaCapturePipelines = output.mediaCapturePipelines
            self.nextToken = output.nextToken
        } else {
            self.mediaCapturePipelines = nil
            self.nextToken = nil
        }
    }
}

public struct ListMediaCapturePipelinesOutputResponse: Swift.Equatable {
    /// The media capture pipeline objects in the list.
    public var mediaCapturePipelines: [ChimeSdkMediaPipelinesClientTypes.MediaCapturePipelineSummary]?
    /// The token used to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init (
        mediaCapturePipelines: [ChimeSdkMediaPipelinesClientTypes.MediaCapturePipelineSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.mediaCapturePipelines = mediaCapturePipelines
        self.nextToken = nextToken
    }
}

struct ListMediaCapturePipelinesOutputResponseBody: Swift.Equatable {
    let mediaCapturePipelines: [ChimeSdkMediaPipelinesClientTypes.MediaCapturePipelineSummary]?
    let nextToken: Swift.String?
}

extension ListMediaCapturePipelinesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mediaCapturePipelines = "MediaCapturePipelines"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mediaCapturePipelinesContainer = try containerValues.decodeIfPresent([ChimeSdkMediaPipelinesClientTypes.MediaCapturePipelineSummary?].self, forKey: .mediaCapturePipelines)
        var mediaCapturePipelinesDecoded0:[ChimeSdkMediaPipelinesClientTypes.MediaCapturePipelineSummary]? = nil
        if let mediaCapturePipelinesContainer = mediaCapturePipelinesContainer {
            mediaCapturePipelinesDecoded0 = [ChimeSdkMediaPipelinesClientTypes.MediaCapturePipelineSummary]()
            for structure0 in mediaCapturePipelinesContainer {
                if let structure0 = structure0 {
                    mediaCapturePipelinesDecoded0?.append(structure0)
                }
            }
        }
        mediaCapturePipelines = mediaCapturePipelinesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let resourceARN = resourceARN {
            let resourceARNQueryItem = ClientRuntime.URLQueryItem(name: "arn".urlPercentEncoding(), value: Swift.String(resourceARN).urlPercentEncoding())
            items.append(resourceARNQueryItem)
        }
        return items
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/tags"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The resource ARN.
    /// This member is required.
    public var resourceARN: Swift.String?

    public init (
        resourceARN: Swift.String? = nil
    )
    {
        self.resourceARN = resourceARN
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// The tag key-value pairs.
    public var tags: [ChimeSdkMediaPipelinesClientTypes.Tag]?

    public init (
        tags: [ChimeSdkMediaPipelinesClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [ChimeSdkMediaPipelinesClientTypes.Tag]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([ChimeSdkMediaPipelinesClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ChimeSdkMediaPipelinesClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ChimeSdkMediaPipelinesClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ChimeSdkMediaPipelinesClientTypes.MediaCapturePipeline: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case chimeSdkMeetingConfiguration = "ChimeSdkMeetingConfiguration"
        case createdTimestamp = "CreatedTimestamp"
        case mediaPipelineArn = "MediaPipelineArn"
        case mediaPipelineId = "MediaPipelineId"
        case sinkArn = "SinkArn"
        case sinkType = "SinkType"
        case sourceArn = "SourceArn"
        case sourceType = "SourceType"
        case status = "Status"
        case updatedTimestamp = "UpdatedTimestamp"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let chimeSdkMeetingConfiguration = self.chimeSdkMeetingConfiguration {
            try encodeContainer.encode(chimeSdkMeetingConfiguration, forKey: .chimeSdkMeetingConfiguration)
        }
        if let createdTimestamp = self.createdTimestamp {
            try encodeContainer.encode(createdTimestamp.timeIntervalSince1970, forKey: .createdTimestamp)
        }
        if let mediaPipelineArn = self.mediaPipelineArn {
            try encodeContainer.encode(mediaPipelineArn, forKey: .mediaPipelineArn)
        }
        if let mediaPipelineId = self.mediaPipelineId {
            try encodeContainer.encode(mediaPipelineId, forKey: .mediaPipelineId)
        }
        if let sinkArn = self.sinkArn {
            try encodeContainer.encode(sinkArn, forKey: .sinkArn)
        }
        if let sinkType = self.sinkType {
            try encodeContainer.encode(sinkType.rawValue, forKey: .sinkType)
        }
        if let sourceArn = self.sourceArn {
            try encodeContainer.encode(sourceArn, forKey: .sourceArn)
        }
        if let sourceType = self.sourceType {
            try encodeContainer.encode(sourceType.rawValue, forKey: .sourceType)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let updatedTimestamp = self.updatedTimestamp {
            try encodeContainer.encode(updatedTimestamp.timeIntervalSince1970, forKey: .updatedTimestamp)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mediaPipelineIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mediaPipelineId)
        mediaPipelineId = mediaPipelineIdDecoded
        let mediaPipelineArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mediaPipelineArn)
        mediaPipelineArn = mediaPipelineArnDecoded
        let sourceTypeDecoded = try containerValues.decodeIfPresent(ChimeSdkMediaPipelinesClientTypes.MediaPipelineSourceType.self, forKey: .sourceType)
        sourceType = sourceTypeDecoded
        let sourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceArn)
        sourceArn = sourceArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ChimeSdkMediaPipelinesClientTypes.MediaPipelineStatus.self, forKey: .status)
        status = statusDecoded
        let sinkTypeDecoded = try containerValues.decodeIfPresent(ChimeSdkMediaPipelinesClientTypes.MediaPipelineSinkType.self, forKey: .sinkType)
        sinkType = sinkTypeDecoded
        let sinkArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sinkArn)
        sinkArn = sinkArnDecoded
        let createdTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let updatedTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updatedTimestamp)
        updatedTimestamp = updatedTimestampDecoded
        let chimeSdkMeetingConfigurationDecoded = try containerValues.decodeIfPresent(ChimeSdkMediaPipelinesClientTypes.ChimeSdkMeetingConfiguration.self, forKey: .chimeSdkMeetingConfiguration)
        chimeSdkMeetingConfiguration = chimeSdkMeetingConfigurationDecoded
    }
}

extension ChimeSdkMediaPipelinesClientTypes.MediaCapturePipeline: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MediaCapturePipeline(chimeSdkMeetingConfiguration: \(Swift.String(describing: chimeSdkMeetingConfiguration)), createdTimestamp: \(Swift.String(describing: createdTimestamp)), mediaPipelineArn: \(Swift.String(describing: mediaPipelineArn)), mediaPipelineId: \(Swift.String(describing: mediaPipelineId)), sinkType: \(Swift.String(describing: sinkType)), sourceType: \(Swift.String(describing: sourceType)), status: \(Swift.String(describing: status)), updatedTimestamp: \(Swift.String(describing: updatedTimestamp)), sinkArn: \"CONTENT_REDACTED\", sourceArn: \"CONTENT_REDACTED\")"}
}

extension ChimeSdkMediaPipelinesClientTypes {
    /// A media capture pipeline object consisting of an ID, source type, source ARN, a sink type, a sink ARN, and a configuration object.
    public struct MediaCapturePipeline: Swift.Equatable {
        /// The configuration for a specified media capture pipeline. SourceType must be ChimeSdkMeeting.
        public var chimeSdkMeetingConfiguration: ChimeSdkMediaPipelinesClientTypes.ChimeSdkMeetingConfiguration?
        /// The time at which the capture pipeline was created, in ISO 8601 format.
        public var createdTimestamp: ClientRuntime.Date?
        /// The ARN of a media capture pipeline.
        public var mediaPipelineArn: Swift.String?
        /// The ID of a media capture pipeline.
        public var mediaPipelineId: Swift.String?
        /// ARN of the destination to which the media artifacts are saved.
        public var sinkArn: Swift.String?
        /// Destination type to which the media artifacts are saved. You must use an S3 Bucket.
        public var sinkType: ChimeSdkMediaPipelinesClientTypes.MediaPipelineSinkType?
        /// ARN of the source from which the media artifacts are saved.
        public var sourceArn: Swift.String?
        /// Source type from which media artifacts are saved. You must use ChimeMeeting.
        public var sourceType: ChimeSdkMediaPipelinesClientTypes.MediaPipelineSourceType?
        /// The status of the media capture pipeline.
        public var status: ChimeSdkMediaPipelinesClientTypes.MediaPipelineStatus?
        /// The time at which the capture pipeline was updated, in ISO 8601 format.
        public var updatedTimestamp: ClientRuntime.Date?

        public init (
            chimeSdkMeetingConfiguration: ChimeSdkMediaPipelinesClientTypes.ChimeSdkMeetingConfiguration? = nil,
            createdTimestamp: ClientRuntime.Date? = nil,
            mediaPipelineArn: Swift.String? = nil,
            mediaPipelineId: Swift.String? = nil,
            sinkArn: Swift.String? = nil,
            sinkType: ChimeSdkMediaPipelinesClientTypes.MediaPipelineSinkType? = nil,
            sourceArn: Swift.String? = nil,
            sourceType: ChimeSdkMediaPipelinesClientTypes.MediaPipelineSourceType? = nil,
            status: ChimeSdkMediaPipelinesClientTypes.MediaPipelineStatus? = nil,
            updatedTimestamp: ClientRuntime.Date? = nil
        )
        {
            self.chimeSdkMeetingConfiguration = chimeSdkMeetingConfiguration
            self.createdTimestamp = createdTimestamp
            self.mediaPipelineArn = mediaPipelineArn
            self.mediaPipelineId = mediaPipelineId
            self.sinkArn = sinkArn
            self.sinkType = sinkType
            self.sourceArn = sourceArn
            self.sourceType = sourceType
            self.status = status
            self.updatedTimestamp = updatedTimestamp
        }
    }

}

extension ChimeSdkMediaPipelinesClientTypes.MediaCapturePipelineSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mediaPipelineArn = "MediaPipelineArn"
        case mediaPipelineId = "MediaPipelineId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let mediaPipelineArn = self.mediaPipelineArn {
            try encodeContainer.encode(mediaPipelineArn, forKey: .mediaPipelineArn)
        }
        if let mediaPipelineId = self.mediaPipelineId {
            try encodeContainer.encode(mediaPipelineId, forKey: .mediaPipelineId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mediaPipelineIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mediaPipelineId)
        mediaPipelineId = mediaPipelineIdDecoded
        let mediaPipelineArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mediaPipelineArn)
        mediaPipelineArn = mediaPipelineArnDecoded
    }
}

extension ChimeSdkMediaPipelinesClientTypes {
    /// A summary of a media capture pipeline.
    public struct MediaCapturePipelineSummary: Swift.Equatable {
        /// The ARN of a media capture pipeline.
        public var mediaPipelineArn: Swift.String?
        /// The ID of a media capture pipeline.
        public var mediaPipelineId: Swift.String?

        public init (
            mediaPipelineArn: Swift.String? = nil,
            mediaPipelineId: Swift.String? = nil
        )
        {
            self.mediaPipelineArn = mediaPipelineArn
            self.mediaPipelineId = mediaPipelineId
        }
    }

}

extension ChimeSdkMediaPipelinesClientTypes {
    public enum MediaPipelineSinkType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case s3bucket
        case sdkUnknown(Swift.String)

        public static var allCases: [MediaPipelineSinkType] {
            return [
                .s3bucket,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .s3bucket: return "S3Bucket"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MediaPipelineSinkType(rawValue: rawValue) ?? MediaPipelineSinkType.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSdkMediaPipelinesClientTypes {
    public enum MediaPipelineSourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case chimesdkmeeting
        case sdkUnknown(Swift.String)

        public static var allCases: [MediaPipelineSourceType] {
            return [
                .chimesdkmeeting,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .chimesdkmeeting: return "ChimeSdkMeeting"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MediaPipelineSourceType(rawValue: rawValue) ?? MediaPipelineSourceType.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSdkMediaPipelinesClientTypes {
    public enum MediaPipelineStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case inprogress
        case initializing
        case stopped
        case stopping
        case sdkUnknown(Swift.String)

        public static var allCases: [MediaPipelineStatus] {
            return [
                .failed,
                .inprogress,
                .initializing,
                .stopped,
                .stopping,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "Failed"
            case .inprogress: return "InProgress"
            case .initializing: return "Initializing"
            case .stopped: return "Stopped"
            case .stopping: return "Stopping"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MediaPipelineStatus(rawValue: rawValue) ?? MediaPipelineStatus.sdkUnknown(rawValue)
        }
    }
}

extension NotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: NotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
            self.requestId = output.requestId
        } else {
            self.code = nil
            self.message = nil
            self.requestId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// One or more of the resources in the request does not exist in the system.
public struct NotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: ChimeSdkMediaPipelinesClientTypes.ErrorCode?
    public var message: Swift.String?
    /// The request id associated with the call responsible for the exception.
    public var requestId: Swift.String?

    public init (
        code: ChimeSdkMediaPipelinesClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
        self.requestId = requestId
    }
}

struct NotFoundExceptionBody: Swift.Equatable {
    let code: ChimeSdkMediaPipelinesClientTypes.ErrorCode?
    let message: Swift.String?
    let requestId: Swift.String?
}

extension NotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
        case requestId = "RequestId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeSdkMediaPipelinesClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension ResourceLimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
            self.requestId = output.requestId
        } else {
            self.code = nil
            self.message = nil
            self.requestId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request exceeds the resource limit.
public struct ResourceLimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: ChimeSdkMediaPipelinesClientTypes.ErrorCode?
    public var message: Swift.String?
    /// The request id associated with the call responsible for the exception.
    public var requestId: Swift.String?

    public init (
        code: ChimeSdkMediaPipelinesClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
        self.requestId = requestId
    }
}

struct ResourceLimitExceededExceptionBody: Swift.Equatable {
    let code: ChimeSdkMediaPipelinesClientTypes.ErrorCode?
    let message: Swift.String?
    let requestId: Swift.String?
}

extension ResourceLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
        case requestId = "RequestId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeSdkMediaPipelinesClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension ChimeSdkMediaPipelinesClientTypes.SelectedVideoStreams: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attendeeIds = "AttendeeIds"
        case externalUserIds = "ExternalUserIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attendeeIds = attendeeIds {
            var attendeeIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attendeeIds)
            for attendeeidlist0 in attendeeIds {
                try attendeeIdsContainer.encode(attendeeidlist0)
            }
        }
        if let externalUserIds = externalUserIds {
            var externalUserIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .externalUserIds)
            for externaluseridlist0 in externalUserIds {
                try externalUserIdsContainer.encode(externaluseridlist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attendeeIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .attendeeIds)
        var attendeeIdsDecoded0:[Swift.String]? = nil
        if let attendeeIdsContainer = attendeeIdsContainer {
            attendeeIdsDecoded0 = [Swift.String]()
            for string0 in attendeeIdsContainer {
                if let string0 = string0 {
                    attendeeIdsDecoded0?.append(string0)
                }
            }
        }
        attendeeIds = attendeeIdsDecoded0
        let externalUserIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .externalUserIds)
        var externalUserIdsDecoded0:[Swift.String]? = nil
        if let externalUserIdsContainer = externalUserIdsContainer {
            externalUserIdsDecoded0 = [Swift.String]()
            for string0 in externalUserIdsContainer {
                if let string0 = string0 {
                    externalUserIdsDecoded0?.append(string0)
                }
            }
        }
        externalUserIds = externalUserIdsDecoded0
    }
}

extension ChimeSdkMediaPipelinesClientTypes {
    /// The video streams to capture for a specified media capture pipeline. The total number of video streams can't exceed 25.
    public struct SelectedVideoStreams: Swift.Equatable {
        /// The attendee IDs of the streams selected for a media capture pipeline.
        public var attendeeIds: [Swift.String]?
        /// The external user IDs of the streams selected for a media capture pipeline.
        public var externalUserIds: [Swift.String]?

        public init (
            attendeeIds: [Swift.String]? = nil,
            externalUserIds: [Swift.String]? = nil
        )
        {
            self.attendeeIds = attendeeIds
            self.externalUserIds = externalUserIds
        }
    }

}

extension ServiceFailureException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceFailureExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
            self.requestId = output.requestId
        } else {
            self.code = nil
            self.message = nil
            self.requestId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The service encountered an unexpected error.
public struct ServiceFailureException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var code: ChimeSdkMediaPipelinesClientTypes.ErrorCode?
    public var message: Swift.String?
    /// The request id associated with the call responsible for the exception.
    public var requestId: Swift.String?

    public init (
        code: ChimeSdkMediaPipelinesClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
        self.requestId = requestId
    }
}

struct ServiceFailureExceptionBody: Swift.Equatable {
    let code: ChimeSdkMediaPipelinesClientTypes.ErrorCode?
    let message: Swift.String?
    let requestId: Swift.String?
}

extension ServiceFailureExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
        case requestId = "RequestId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeSdkMediaPipelinesClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension ServiceUnavailableException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceUnavailableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
            self.requestId = output.requestId
        } else {
            self.code = nil
            self.message = nil
            self.requestId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The service is currently unavailable.
public struct ServiceUnavailableException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var code: ChimeSdkMediaPipelinesClientTypes.ErrorCode?
    public var message: Swift.String?
    /// The request id associated with the call responsible for the exception.
    public var requestId: Swift.String?

    public init (
        code: ChimeSdkMediaPipelinesClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
        self.requestId = requestId
    }
}

struct ServiceUnavailableExceptionBody: Swift.Equatable {
    let code: ChimeSdkMediaPipelinesClientTypes.ErrorCode?
    let message: Swift.String?
    let requestId: Swift.String?
}

extension ServiceUnavailableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
        case requestId = "RequestId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeSdkMediaPipelinesClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension ChimeSdkMediaPipelinesClientTypes.SourceConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case selectedVideoStreams = "SelectedVideoStreams"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let selectedVideoStreams = self.selectedVideoStreams {
            try encodeContainer.encode(selectedVideoStreams, forKey: .selectedVideoStreams)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let selectedVideoStreamsDecoded = try containerValues.decodeIfPresent(ChimeSdkMediaPipelinesClientTypes.SelectedVideoStreams.self, forKey: .selectedVideoStreams)
        selectedVideoStreams = selectedVideoStreamsDecoded
    }
}

extension ChimeSdkMediaPipelinesClientTypes {
    /// Source configuration for a specified media capture pipeline.
    public struct SourceConfiguration: Swift.Equatable {
        /// The selected video streams to capture for a specified media capture pipeline. The number of video streams can't exceed 25.
        public var selectedVideoStreams: ChimeSdkMediaPipelinesClientTypes.SelectedVideoStreams?

        public init (
            selectedVideoStreams: ChimeSdkMediaPipelinesClientTypes.SelectedVideoStreams? = nil
        )
        {
            self.selectedVideoStreams = selectedVideoStreams
        }
    }

}

extension ChimeSdkMediaPipelinesClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension ChimeSdkMediaPipelinesClientTypes {
    /// Describes a tag applied to a resource.
    public struct Tag: Swift.Equatable {
        /// The key of the tag.
        /// This member is required.
        public var key: Swift.String?
        /// The value of the tag.
        /// This member is required.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        items.append(ClientRuntime.URLQueryItem(name: "operation", value: "tag-resource"))
        return items
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/tags"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The resource ARN.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// The tag key-value pairs.
    /// This member is required.
    public var tags: [ChimeSdkMediaPipelinesClientTypes.Tag]?

    public init (
        resourceARN: Swift.String? = nil,
        tags: [ChimeSdkMediaPipelinesClientTypes.Tag]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let resourceARN: Swift.String?
    let tags: [ChimeSdkMediaPipelinesClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ChimeSdkMediaPipelinesClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ChimeSdkMediaPipelinesClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ChimeSdkMediaPipelinesClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension ThrottledClientException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ThrottledClientExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
            self.requestId = output.requestId
        } else {
            self.code = nil
            self.message = nil
            self.requestId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The client exceeded its request rate limit.
public struct ThrottledClientException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: ChimeSdkMediaPipelinesClientTypes.ErrorCode?
    public var message: Swift.String?
    /// The request id associated with the call responsible for the exception.
    public var requestId: Swift.String?

    public init (
        code: ChimeSdkMediaPipelinesClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
        self.requestId = requestId
    }
}

struct ThrottledClientExceptionBody: Swift.Equatable {
    let code: ChimeSdkMediaPipelinesClientTypes.ErrorCode?
    let message: Swift.String?
    let requestId: Swift.String?
}

extension ThrottledClientExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
        case requestId = "RequestId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeSdkMediaPipelinesClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension UnauthorizedClientException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UnauthorizedClientExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
            self.requestId = output.requestId
        } else {
            self.code = nil
            self.message = nil
            self.requestId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The client is not currently authorized to make the request.
public struct UnauthorizedClientException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: ChimeSdkMediaPipelinesClientTypes.ErrorCode?
    public var message: Swift.String?
    /// The request id associated with the call responsible for the exception.
    public var requestId: Swift.String?

    public init (
        code: ChimeSdkMediaPipelinesClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
        self.requestId = requestId
    }
}

struct UnauthorizedClientExceptionBody: Swift.Equatable {
    let code: ChimeSdkMediaPipelinesClientTypes.ErrorCode?
    let message: Swift.String?
    let requestId: Swift.String?
}

extension UnauthorizedClientExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
        case requestId = "RequestId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeSdkMediaPipelinesClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension UntagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkeylist0 in tagKeys {
                try tagKeysContainer.encode(tagkeylist0)
            }
        }
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        items.append(ClientRuntime.URLQueryItem(name: "operation", value: "untag-resource"))
        return items
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/tags"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The resource ARN.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// The tag keys.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceARN: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    let resourceARN: Swift.String?
    let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceFailureException" : self = .serviceFailureException(try ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledClientException" : self = .throttledClientException(try ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedClientException" : self = .unauthorizedClientException(try UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case notFoundException(NotFoundException)
    case serviceFailureException(ServiceFailureException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttledClientException(ThrottledClientException)
    case unauthorizedClientException(UnauthorizedClientException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension ChimeSdkMediaPipelinesClientTypes.VideoArtifactsConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case muxType = "MuxType"
        case state = "State"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let muxType = self.muxType {
            try encodeContainer.encode(muxType.rawValue, forKey: .muxType)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateDecoded = try containerValues.decodeIfPresent(ChimeSdkMediaPipelinesClientTypes.ArtifactsState.self, forKey: .state)
        state = stateDecoded
        let muxTypeDecoded = try containerValues.decodeIfPresent(ChimeSdkMediaPipelinesClientTypes.VideoMuxType.self, forKey: .muxType)
        muxType = muxTypeDecoded
    }
}

extension ChimeSdkMediaPipelinesClientTypes {
    /// The video artifact configuration object.
    public struct VideoArtifactsConfiguration: Swift.Equatable {
        /// The MUX type of the video artifact configuration object.
        public var muxType: ChimeSdkMediaPipelinesClientTypes.VideoMuxType?
        /// Indicates whether the video artifact is enabled or disabled.
        /// This member is required.
        public var state: ChimeSdkMediaPipelinesClientTypes.ArtifactsState?

        public init (
            muxType: ChimeSdkMediaPipelinesClientTypes.VideoMuxType? = nil,
            state: ChimeSdkMediaPipelinesClientTypes.ArtifactsState? = nil
        )
        {
            self.muxType = muxType
            self.state = state
        }
    }

}

extension ChimeSdkMediaPipelinesClientTypes {
    public enum VideoMuxType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case videoonly
        case sdkUnknown(Swift.String)

        public static var allCases: [VideoMuxType] {
            return [
                .videoonly,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .videoonly: return "VideoOnly"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = VideoMuxType(rawValue: rawValue) ?? VideoMuxType.sdkUnknown(rawValue)
        }
    }
}
